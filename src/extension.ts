// Description: This file contains the extension logic for the VaporView extension

import * as vscode from 'vscode';
import { Worker } from 'worker_threads';
import * as fs from 'fs';
import { promisify } from 'util';

// Import the code generated by wit2ts
import { filehandler } from './filehandler';

const wasmDebug = 'debug';
const wasmRelease = 'release';
const wasmBuild = wasmRelease;

interface VaporviewDocumentDelegate {
  getViewerContext(): Promise<Uint8Array>;
  updateViews(uri: vscode.Uri): void;
}

let wasmModule: WebAssembly.Module;
type WaveformTopMetadata = {
  fileSize:    number;
  fd:          number;
  timeTableLoaded: boolean;
  moduleCount: number;
  netlistIdCount: number;
  signalIdCount: number;
  timeEnd:     number;
  chunkTime:   number;
  chunkCount:  number;
  timeScale:   number;
  defaultZoom: number;
  timeUnit:    string;
};

export type NetlistIdTable = NetlistIdRef[];
export type TransitionData = [number, number | string];
export type SignalId  = number;
export type NetlistId = number;
export type NetlistIdRef = {
  netlistItem: NetlistItem;
  displayedItem: NetlistItem | undefined;
  signalId: SignalId;
};

const moduleIcon = new vscode.ThemeIcon('chip',             new vscode.ThemeColor('charts.purple'));
const funcIcon   = new vscode.ThemeIcon('symbol-module',    new vscode.ThemeColor('charts.yellow'));
const scopeIcon  = new vscode.ThemeIcon('symbol-module',    new vscode.ThemeColor('charts.white'));
const regIcon    = new vscode.ThemeIcon('symbol-array',     new vscode.ThemeColor('charts.green'));
const wireIcon   = new vscode.ThemeIcon('symbol-interface', new vscode.ThemeColor('charts.pink'));
const intIcon    = new vscode.ThemeIcon('symbol-variable',  new vscode.ThemeColor('charts.blue'));
const paramIcon  = new vscode.ThemeIcon('settings',         new vscode.ThemeColor('charts.orange'));
const realIcon   = new vscode.ThemeIcon('symbol-constant',  new vscode.ThemeColor('charts.purple'));

export function createScope(name: string, type: string, path: string, netlistId: number) {

  const typename = type.toLocaleLowerCase();
  let icon = scopeIcon;
  if      (typename === 'module' ) {icon = moduleIcon;} 
  else if (typename === 'function') {icon = funcIcon;}

  const module    = new NetlistItem(name, 'module', 0, 0, netlistId, name, path, 0, 0, [], vscode.TreeItemCollapsibleState.Collapsed);
  module.iconPath = icon;

  return module;
}

function bitRangeString(msb: number, lsb: number): string {
  if (msb < 0 || lsb < 0) {return "";}
  if (msb === lsb) {return " [" + msb + "]";}
  return " [" + msb + ":" + lsb + "]";
}

export function createVar(name: string, type: string, path: string, netlistId: NetlistId, signalId: SignalId, width: number, msb: number, lsb: number) {
  const field = bitRangeString(msb, lsb);
  const variable = new NetlistItem(name + field, type, width, signalId, netlistId, name, path, msb, lsb, [], vscode.TreeItemCollapsibleState.None, vscode.TreeItemCheckboxState.Unchecked);
  const typename = type.toLocaleLowerCase();
  if ((typename === 'wire') || (typename === 'reg')) {
    if (width > 1) {variable.iconPath = regIcon;}
    else           {variable.iconPath = wireIcon;}
  }
  else if (typename === 'integer')   {variable.iconPath = intIcon;}
  else if (typename === 'parameter') {variable.iconPath = paramIcon;}
  else if (typename === 'real')      {variable.iconPath = realIcon;}

  return variable;
}

// #region VaporviewDocument
export class VaporviewDocument extends vscode.Disposable implements vscode.CustomDocument {

  private open  = promisify(fs.open);
  private close = promisify(fs.close);

  private readonly _uri: vscode.Uri;
  // Hierarchy
  public treeData:         NetlistItem[] = [];
  public displayedSignals: NetlistItem[] = [];
  private _netlistIdTable: NetlistIdTable = [];
  // Wasm
  private readonly _delegate: VaporviewDocumentDelegate;
  public _wasmWorker: Worker;
  public wasmApi: any;
  // Webview
  public webviewPanel: vscode.WebviewPanel | undefined = undefined;
  private _webviewInitialized: boolean = false;
  public metadata:   WaveformTopMetadata = {
    fileSize:    0,
    fd:          0,
    timeTableLoaded: false,
    moduleCount:    0,
    netlistIdCount: 0,
    signalIdCount:  0,
    timeEnd:     0,
    chunkTime:   128,
    chunkCount:  0,
    timeScale:   1,
    defaultZoom: 1,
    timeUnit:    "ns",
  };

  static async create(
    uri: vscode.Uri,
    backupId: string | undefined,
    wasmWorker: Worker,
    delegate: VaporviewDocumentDelegate,
  ): Promise<VaporviewDocument | PromiseLike<VaporviewDocument>> {

    const document = new VaporviewDocument(uri, wasmWorker, delegate);
    await document.createWasmApi();
    document.load();
    return document;
  }

  private constructor(
    uri: vscode.Uri,
    _wasmWorker: Worker,
    delegate: VaporviewDocumentDelegate,
  ) {
    super(() => this.dispose());
    this._uri = uri;
    this._wasmWorker = _wasmWorker;
    this._delegate = delegate;
  }

  private async load() {
    const stats    = fs.statSync(this.uri.fsPath);
    const fileType = this.uri.fsPath.split('.').pop()?.toLocaleLowerCase();
    this.metadata.fd       = await this.open(this.uri.fsPath, 'r');
    this.metadata.fileSize = stats.size;
    const fstMaxStaticLoadSize = vscode.workspace.getConfiguration('vaporview').get('fstMaxStaticLoadSize');
    const maxStaticSize        = Number(fstMaxStaticLoadSize) * 1048576;

    let loadStatic = true;
    if (fileType === 'fst' && stats.size > maxStaticSize) {
      loadStatic = false;
    }
    //loadStatic = true;

    if (loadStatic === false) {
      vscode.window.showInformationMessage(
        this.uri.fsPath + ' is larger than the max static load size of ' + fstMaxStaticLoadSize +
        ' MB. File will be loaded dynamically. You can configure the max load size in your extension settings.');
    }

    await vscode.window.withProgress({
      location: vscode.ProgressLocation.Notification,
      title: "Parsing Netlist",
      cancellable: false
    }, async () => {
      await this.wasmApi.loadfile(BigInt(stats.size), this.metadata.fd, loadStatic);
    });

    this._delegate.updateViews(this.uri);
    await this._readBody();
  }

  public readonly service: filehandler.Imports.Promisified = {

    log: (msg: string) => {console.log(msg);},
    fsread: (fd: number, offset: bigint, length: number): Uint8Array => {

      const filebuffer = Buffer.alloc(length);
      const bytesRead = fs.readSync(fd, filebuffer, 0, length, Number(offset));

      return new Uint8Array(filebuffer);
    },
    getsize: (fd: number): bigint => {
      const stats = fs.fstatSync(fd);
      return BigInt(stats.size);
    },
    setscopetop: (name: string, id: number, tpe: string) => {

      const scope = createScope(name, tpe, "", id);
      this.treeData.push(scope);
      this._netlistIdTable[id] = {netlistItem: scope, displayedItem: undefined, signalId: 0};
    },
    setmetadata: (scopecount: number, varcount: number, timescale: number, timeunit: string) => {
      this.metadata.moduleCount = scopecount;
      this.metadata.netlistIdCount = varcount;
      this.metadata.timeScale = timescale;
      this.metadata.timeUnit = timeunit;
      this._netlistIdTable = new Array(varcount);
    },
    setchunksize: (chunksize: bigint, timeend: bigint) => {
      this.setChunkSize(Number(chunksize));
      this.metadata.timeEnd = Number(timeend);
      this.metadata.chunkCount = Math.ceil(this.metadata.timeEnd / this.metadata.chunkTime);
      this.metadata.timeTableLoaded = true;
      this.onDoneParsingWaveforms();
    },
    sendtransitiondatachunk: (signalid: number, totalchunks: number, chunknum: number, transitionData: string) => {

      this.webviewPanel?.webview.postMessage({
        command: 'update-waveform-chunk',
        signalId: signalid,
        transitionDataChunk: transitionData,
        totalChunks: totalchunks,
        chunkNum: chunknum
      });
    }
  };
  // The implementation of the log function that is called from WASM

  public get uri() { return this._uri; }
  public get netlistIdTable(): NetlistIdTable { return this._netlistIdTable; }
  public get webviewInitialized(): boolean { return this._webviewInitialized; }

  public async createWasmApi() {
    this.wasmApi = await filehandler._.bind(this.service, wasmModule, this._wasmWorker);
  }

  private _readBody() {
    vscode.window.withProgress({
      location: vscode.ProgressLocation.Notification,
      title: "Parsing Waveforms",
      cancellable: false
    }, async (progress) => {
      await this.wasmApi.readbody();
    });
  }

  public onWebviewReady(webviewPanel: vscode.WebviewPanel) {
    console.log("Webview Ready");
    this.webviewPanel = webviewPanel;
    if (this._webviewInitialized) {return;}
    if (!this.metadata.timeTableLoaded) {return;}
    //console.log("creating ruler");
    webviewPanel.webview.postMessage({
      command: 'create-ruler',
      waveformDataSet: this.metadata,
    });
    //console.log(this.metadata);
    this._webviewInitialized = true;
  }

  public onDoneParsingWaveforms() {
    console.log("onDoneParsingWaveforms");
    if (this.webviewPanel) {
      this.onWebviewReady(this.webviewPanel);
    }
    //this.close(this.metadata.fd);
  }

  public setNetlistIdTable(netlistId: NetlistId, displayedSignalViewRef: NetlistItem | undefined) {
    const viewRef = this._netlistIdTable[netlistId];
    if (viewRef === undefined) {return;}
    viewRef.displayedItem = displayedSignalViewRef;
    this._netlistIdTable[netlistId] = viewRef;
  }

  public setChunkSize(minTimeStemp: number) {
    // Prevent weird zoom ratios causing strange floating point math errors
    const newMinTimeStemp     = 10 ** (Math.round(Math.log10(minTimeStemp / 128)) | 0);
    const chunkTime           = newMinTimeStemp * 128;
    this.metadata.chunkTime   = chunkTime;
    this.metadata.defaultZoom = 512 / chunkTime;
  }

  public async findTreeItem(modulePath: string, msb: number | undefined, lsb: number | undefined): Promise<NetlistItem | null> {
    const module = this.treeData.find((element) => element.label === modulePath.split('.')[0]);
    if (!module) {return null;}
    return await module.findChild(modulePath.split('.').slice(1).join('.'), this, msb, lsb);
  }

  async getChildrenExternal(element: NetlistItem | undefined) {

    if (!element) {return Promise.resolve(this.treeData);} // Return the top-level netlist items
    if (!this.wasmApi) {return Promise.resolve([]);}
    if (element.children.length > 0) {return Promise.resolve(element.children);}

    let modulePath = "";
    if (element.modulePath !== "") {modulePath += element.modulePath + ".";}
    modulePath += element.name;
    let itemsRemaining = Infinity;
    let startIndex     = 0;
    const result: NetlistItem[] = [];

    //console.log(element);
    let callLimit = 255;
    const varTable: any = {};
    while (itemsRemaining > 0) {
      //console.log("calling getscopes for " + modulePath + " with start index " + startIndex);
      const children = await this.wasmApi.getchildren(element.netlistId, startIndex);
      const childItems = JSON.parse(children);
      //console.log(children);
      //console.log(childItems);
      itemsRemaining = childItems.remainingItems;
      startIndex    += childItems.totalReturned;

      childItems.scopes.forEach((child: any) => {
        result.push(createScope(child.name, child.type, modulePath, child.id));
      });
      childItems.vars.forEach((child: any) => {
        // Need to handle the case where we get a variable with the same name but
        // different bit ranges.
        const varItem = createVar(child.name, child.type, modulePath, child.netlistId, child.signalId, child.width, child.msb, child.lsb);
        if (varTable[child.name] === undefined) {
          varTable[child.name] = [varItem];
        } else {
          varTable[child.name].push(varItem);
        }
        this.netlistIdTable[child.netlistId] = {netlistItem: varItem, displayedItem: undefined, signalId: child.signalId};
      });

      callLimit--;
      if (callLimit <= 0) {break;}
    }

    for (const [key, value] of Object.entries(varTable)) {
      if ((value as NetlistItem[]).length === 1) {
        result.push((value as NetlistItem[])[0]);
      } else {
        const varList = value as NetlistItem[];
        const bitList: NetlistItem[] = [];
        const busList: NetlistItem[] = [];
        let maxWidth = 0;
        let parent: any = undefined; // set to any because the linter is complaining
        varList.forEach((varItem) => {
          if (varItem.width === 1) {bitList.push(varItem);}
          else {busList.push(varItem);}
        });
        busList.forEach((busItem: NetlistItem) => {
          if (busItem.width > maxWidth) {
            maxWidth = busItem.width;
            parent = busItem;
          }
          result.push(busItem);
        });
        if (parent !== undefined) {
          parent.children = bitList;
          parent.collapsibleState = vscode.TreeItemCollapsibleState.Collapsed;
        } else {
          result.push(...bitList);
        }

      }
    }

    element.children = result;
    return Promise.resolve(element.children);
  }

  public async unload() {
    console.log("Reloading document");
    this.treeData         = [];
    this.displayedSignals = [];
    this._netlistIdTable  = [];
    this.close(this.metadata.fd);
    await this.wasmApi.unload();
    this.metadata.timeTableLoaded = false;
    this.webviewPanel?.webview.postMessage({command: 'unload'});
    this._webviewInitialized = false;
  }

  public async reload() {

    await this.unload();
    await this.load();
  }

  //private readonly _onDidDispose = this._register(new vscode.EventEmitter<void>());
  /**
   * Fired when the document is disposed of.
   */
  //public readonly onDidDispose = this._onDidDispose.event;

  /**
   * Called by VS Code when there are no more references to the document.
   * This happens when all editors for it have been closed.
   */
  dispose(): void {
    this.unload();
    this._wasmWorker.terminate();
    this._delegate.updateViews(this.uri);
    //this._onDidDispose.fire();
  }
}

// #region WaveformViewerProvider
class WaveformViewerProvider implements vscode.CustomReadonlyEditorProvider<VaporviewDocument> {

  private static newViewerId = 1;
  private static readonly viewType = 'vaporview.waveformViewer';
  private readonly webviews = new WebviewCollection();
  private activeWebview: vscode.WebviewPanel | undefined;
  private activeDocument: VaporviewDocument | undefined;
  private lastActiveWebview: vscode.WebviewPanel | undefined;
  private lastActiveDocument: VaporviewDocument | undefined;

  public netlistTreeDataProvider: NetlistTreeDataProvider;
  public netlistView: vscode.TreeView<NetlistItem>;
  public displayedSignalsTreeDataProvider: DisplayedSignalsViewProvider;
  public displayedSignalsView: vscode.TreeView<NetlistItem>;
  public deltaTimeStatusBarItem: vscode.StatusBarItem;
  public markerTimeStatusBarItem: vscode.StatusBarItem;
  public selectedSignalStatusBarItem: vscode.StatusBarItem;

  public netlistViewSelectedSignals: NetlistItem[] = [];
  public displayedSignalsViewSelectedSignals: NetlistItem[] = [];
  public log: vscode.OutputChannel;

  public webviewContext = {
    markerTime: null,
    altMarkerTime: null,
    selectedSignal: null,
    displayedSignals: [],
    zoomRatio: 1,
    scrollLeft: 0,
    numberFormat: 16,
  };

  constructor(private readonly _context: vscode.ExtensionContext) {

    // The channel for printing the log.
    this.log = vscode.window.createOutputChannel('Vaporview Log', { log: true });
    _context.subscriptions.push(this.log);

    // Create and register the Netlist and Displayed Signals view container
    this.netlistTreeDataProvider = new NetlistTreeDataProvider();
    this.netlistView = vscode.window.createTreeView('netlistContainer', {
      treeDataProvider: this.netlistTreeDataProvider,
      manageCheckboxStateManually: true,
      canSelectMany: true,
    });
    this._context.subscriptions.push(this.netlistView);

    this.displayedSignalsTreeDataProvider = new DisplayedSignalsViewProvider();
    this.displayedSignalsView = vscode.window.createTreeView('displaylistContainer', {
      treeDataProvider: this.displayedSignalsTreeDataProvider,
      manageCheckboxStateManually: true,
      canSelectMany: true,
    });
    this._context.subscriptions.push(this.displayedSignalsView);

    // Create a status bar item for marker time and
    this.deltaTimeStatusBarItem      = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right, 100);
    this.markerTimeStatusBarItem     = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right, 99);
    this.selectedSignalStatusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right, 98);
  }

  private getNameFromNetlistId(netlistId: NetlistId | null) {
    if (netlistId === null) {return null;}
    const netlistData  = this.activeDocument?.netlistIdTable[netlistId]?.netlistItem;
    const modulePath   = netlistData?.modulePath;
    const signalName   = netlistData?.name;
    const numberFormat = netlistData?.numberFormat;
    const msb          = netlistData?.msb;
    const lsb          = netlistData?.lsb;
    return {
      name: modulePath + '.' + signalName,
      numberFormat: numberFormat,
      msb: msb,
      lsb: lsb,
    };
  }

  public getSettings() {
    if (!this.activeDocument) {return;}
    return {
      extensionVersion: vscode.extensions.getExtension('Lramseyer.vaporview')?.packageJSON.version,
      fileName: this.activeDocument.uri.fsPath,
      markerTime: this.webviewContext.markerTime,
      altMarkerTime: this.webviewContext.altMarkerTime,
      selectedSignal: this.getNameFromNetlistId(this.webviewContext.selectedSignal),
      zoomRatio: this.webviewContext.zoomRatio,
      scrollLeft: this.webviewContext.scrollLeft,
      displayedSignals: this.webviewContext.displayedSignals.map((n: NetlistId) => {return this.getNameFromNetlistId(n);}),
    };
  }

  public saveSettingsToFile() {
    if (!this.activeDocument) {
      vscode.window.showErrorMessage('No viewer is active. Please select the viewer you wish to save settings.');
      return;
    }

    const saveData       = this.getSettings();
    const saveDataString = JSON.stringify(saveData, null, 2);

    vscode.window.showSaveDialog({
      saveLabel: 'Save settings',
      filters: {JSON: ['json']}
    }).then((uri) => {
      if (uri) {
        vscode.workspace.fs.writeFile(uri, new TextEncoder().encode(saveDataString));
      }
    });
  }

  public async loadSettingsFromFile() {

    if (!this.activeDocument) {
      vscode.window.showErrorMessage('No viewer is active. Please select the viewer you wish to load settings.');
      return;
    }

    //let version  = vscode.extensions.getExtension('Lramseyer.vaporview')?.packageJSON.version;
    // show open file diaglog
    const fileData = await new Promise<any>((resolve, reject) => {
      vscode.window.showOpenDialog({
        canSelectFiles: true,
        canSelectFolders: false,
        canSelectMany: false,
        openLabel: 'Load settings',
        filters: { JSON: ['json'] }
      }).then((uri) => {
        if (uri) {
          vscode.workspace.fs.readFile(uri[0]).then((data) => {
            const fileData = JSON.parse(new TextDecoder().decode(data));
            resolve(fileData);
          }, (error: any) => {
            reject(error); // Reject if readFile fails
          });
        } else {
          reject("No file selected"); // Reject if no file is selected
        }
      }, (error: any) => {
        reject(error); // Reject if showOpenDialog fails
      });
    });

    if (!fileData) {return;}
    if (fileData.fileName && fileData.fileName !== this.activeDocument.uri.fsPath) {
      vscode.window.showWarningMessage('The settings file may not match the active viewer');
    }

    this.applySettings(fileData);
  }

  public async applySettings(settings: any) {
    const missingSignals: string[] = [];
    const foundSignals: any[] = [];

    if (!this.activeDocument) {return;}

    if (settings.displayedSignals) {
      for (const signalInfo of settings.displayedSignals) {
        const signal = signalInfo.name;
        const numberFormat = signalInfo.numberFormat;
        const metaData = await this.activeDocument.findTreeItem(signal, signalInfo.msb, signalInfo.lsb);
        if (metaData !== null) {
          foundSignals.push({
            netlistId: metaData.netlistId,
            numberFormat: numberFormat,
          });
        } else {
          missingSignals.push(signal);
        }
      }
    }

    console.log(missingSignals);

    foundSignals.forEach((signalInfo: any) => {
      const netlistId    = signalInfo.netlistId;
      const numberFormat = signalInfo.numberFormat;
      if (!this.webviewContext.displayedSignals.includes(netlistId as never)) {
        this.addSignalToDocument(netlistId, false);
      }
      this.setValueFormat(netlistId, numberFormat);
    });
  }

  //#region CustomEditorProvider
  async openCustomDocument(
    uri: vscode.Uri,
    openContext: { backupId?: string },
    _token: vscode.CancellationToken,
  ): Promise<VaporviewDocument> {

    const delegate = {
      getViewerContext: async () => {
        const webviewsForDocument = Array.from(this.webviews.get(document.uri));
        if (!webviewsForDocument.length) {
          throw new Error('Could not find webview to save for');
        }
        const panel    = webviewsForDocument[0];
        const response = await this.postMessageWithResponse<number[]>(panel, 'getContext', {});
        return new Uint8Array(response);
      },
      updateViews: (uri: vscode.Uri) => {
        if (this.activeDocument?.uri !== uri) {return;}
        this.netlistTreeDataProvider.loadDocument(document);
        this.displayedSignalsTreeDataProvider.setTreeData(document.displayedSignals);
      }
    };

    // Load the Wasm worker
    const workerFile = vscode.Uri.joinPath(this._context.extensionUri, 'out', 'worker.js').fsPath;
    const wasmWorker = new Worker(workerFile);
    const document   = await VaporviewDocument.create(uri, openContext.backupId, wasmWorker, delegate);

    this.netlistTreeDataProvider.loadDocument(document);
    this.displayedSignalsTreeDataProvider.setTreeData(document.displayedSignals);

    return document;
  }

  async reloadFile() {
    if (!this.activeDocument) {return;}
    const settings = this.getSettings();
    this.netlistTreeDataProvider.hide();
    this.displayedSignalsTreeDataProvider.hide();
    await this.activeDocument.reload();
    this.applySettings(settings);
  }

  formatTime = function(time: number, timeScale: number, timeUnit: string) {
    const timeValue = time * timeScale;
    return timeValue.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",") + ' ' + timeUnit;
  };

  copyWaveDrom() {
    this.activeWebview?.webview.postMessage({command: 'copyWaveDrom'});
  }

  setWaveDromClock(edge: string, netlistId: NetlistId | null) {
    this.activeWebview?.webview.postMessage({
      command: 'setWaveDromClock',
      edge: edge,
      netlistId: netlistId,
    });
  }

  scaleFromUnits(unit: string | undefined) {
    switch (unit) {
      case 'fs': return 1e-15;
      case 'ps': return 1e-12;
      case 'ns': return 1e-9;
      case 'us': return 1e-6;
      case 'µs': return 1e-6;
      case 'ms': return 1e-3;
      case 's':  return 1;
      case 'ks': return 1000;
      default: return 1;
    }
  }

  setMarkerAtTimeWithUnits(time: number, unit: string) {

    if (!this.lastActiveDocument) {
      //console.log('No active document');
      return;
    }

    const timeScale   = this.lastActiveDocument.metadata.timeScale;
    const timeUnit    = this.scaleFromUnits(this.lastActiveDocument.metadata.timeUnit);

    if (!timeScale || !timeUnit) {return;}

    const scaleFactor = this.scaleFromUnits(unit) / (timeUnit * timeScale);

    this.setMarkerAtTime(Math.round(time * scaleFactor));
  }

  setMarkerAtTime(time: number) {

    if (!this.lastActiveWebview) {return;}
    if (!this.lastActiveDocument) {return;}

    // Check to see that the time is not out of bounds
    const chunkCount = this.lastActiveDocument.metadata.chunkCount;
    const chunkTime  = this.lastActiveDocument.metadata.chunkTime;
    if (!chunkCount || !chunkTime) {return;}
    if (time < 0 || time > (chunkCount * chunkTime)) {return;}

    this.lastActiveWebview.webview.postMessage({command: 'setMarker', time: time});
  }

  updateStatusBarItems(document: VaporviewDocument) {
    this.deltaTimeStatusBarItem.hide();
    this.markerTimeStatusBarItem.hide();
    this.selectedSignalStatusBarItem.hide();
    const w = this.webviewContext;

    if (!document) {return;}

    if (w.markerTime !== null) {
      const timeScale = document.metadata.timeScale;
      const timeUnit  = document.metadata.timeUnit;
      this.markerTimeStatusBarItem.text = 'time: ' + this.formatTime(w.markerTime, timeScale, timeUnit);
      this.markerTimeStatusBarItem.show();
      if (w.altMarkerTime !== null) {
        const deltaT = w.markerTime - w.altMarkerTime;
        this.deltaTimeStatusBarItem.text = 'Δt: ' + this.formatTime(deltaT, timeScale, timeUnit);
        this.deltaTimeStatusBarItem.show();
      } else {
        this.deltaTimeStatusBarItem.hide();
      }
    } else {
      this.markerTimeStatusBarItem.hide();
    }

    if (w.selectedSignal !== null) {
      const NetlistIdRef = document.netlistIdTable[w.selectedSignal];
      const signalName = NetlistIdRef.netlistItem.name;
      this.selectedSignalStatusBarItem.text = 'Selected signal: ' + signalName;
      this.selectedSignalStatusBarItem.show();
      if (NetlistIdRef.displayedItem) {
        this.displayedSignalsView.reveal(NetlistIdRef.displayedItem, {select: true, focus: false});
      }
    } else {
      this.selectedSignalStatusBarItem.hide();
    }
  }

  showInNetlistView(netlistId: NetlistId) {
    if (!this.activeDocument) {return;}
    const NetlistIdRef = this.activeDocument.netlistIdTable[netlistId];
    if (NetlistIdRef.netlistItem) {
      this.netlistView.reveal(NetlistIdRef.netlistItem, {select: true, focus: false, expand: 3});
    }
  }

  async resolveCustomEditor(
    document: VaporviewDocument,
    webviewPanel: vscode.WebviewPanel,
    _token: vscode.CancellationToken
  ): Promise<void> {

    webviewPanel.onDidDispose(() => {
      if (this.activeWebview === webviewPanel) {
        this.netlistTreeDataProvider.setTreeData([]);
        this.displayedSignalsTreeDataProvider.setTreeData([]);
        this.webviewContext = {
          markerTime: null,
          altMarkerTime: null,
          selectedSignal: null,
          displayedSignals: [],
          zoomRatio: 1,
          scrollLeft: 0,
          numberFormat: 16,
        };
      }
      if (this.lastActiveWebview === webviewPanel) {
        this.lastActiveWebview = undefined;
        this.lastActiveDocument = undefined;
      }
    });

    // Wait for the webview to be properly ready before we init
    webviewPanel.webview.onDidReceiveMessage(e => {
      //console.log(e);
      //console.log(document.uri);

      if (e.type === 'ready') {
        if (document.uri.scheme === 'untitled') {
          //console.log("untitled scheme");
        }
        document.onWebviewReady(webviewPanel);
      }
      switch (e.command) {
        case 'init': {
          // Webview is initialized, send the 'init' message
          break;
        }
        case 'setTime': {
          this.webviewContext.markerTime    = e.markerTime;
          this.webviewContext.altMarkerTime = e.altMarkerTime;

          this.updateStatusBarItems(document);
          break;
        }
        case 'setSelectedSignal': {
          this.webviewContext.selectedSignal = e.netlistId;
          this.updateStatusBarItems(document);
          break;
        }
        case 'contextUpdate' : {

          this.webviewContext.markerTime       = e.markerTime;
          this.webviewContext.altMarkerTime    = e.altMarkerTime;
          this.webviewContext.selectedSignal   = e.selectedSignal;
          this.webviewContext.displayedSignals = e.displayedSignals;
          this.webviewContext.zoomRatio        = e.zoomRatio;
          this.webviewContext.scrollLeft       = e.scrollLeft;
          this.webviewContext.numberFormat     = e.numberFormat;

          this.updateStatusBarItems(document);
          break;
        }
        case 'fetchTransitionData': {
          document.wasmApi.getsignaldata(e.signalId);
          break;
        }
        case 'copyWaveDrom': {
          if (e.maxTransitionsFlag) {
            vscode.window.showWarningMessage('The number of transitions exceeds the maximum limit of ' + e.maxTransitions);
          }
          vscode.env.clipboard.writeText(e.waveDromJson);
          vscode.window.showInformationMessage('WaveDrom JSON copied to clipboard.');
          break;
        }
        case 'close-webview' : {
          //console.log("close-webview");
          // Close the webview
          webviewPanel.dispose();
          break;
        }
      }
      //this.onMessage(document, e);
      switch (e.type) {
        case 'response': {
          const callback = this._callbacks.get(e.requestId);
          callback?.(e.body);
          return;
        }
      }
    });

    webviewPanel.onDidChangeViewState(e => {
      //console.log("onDidChangeViewState()");
      //console.log(vscode.window.activeTextEditor?.document);
      //console.log(e);

      this.netlistViewSelectedSignals = [];
      this.displayedSignalsViewSelectedSignals = [];

      if (e.webviewPanel.active) {
        this.activeWebview  = webviewPanel;
        this.activeDocument = document;
        this.lastActiveWebview = webviewPanel;
        this.lastActiveDocument = document;
        this.netlistTreeDataProvider.loadDocument(document);
        this.displayedSignalsTreeDataProvider.setTreeData(this.activeDocument.displayedSignals);
        webviewPanel.webview.postMessage({command: 'getSelectionContext'});
        this.deltaTimeStatusBarItem.show();
        this.markerTimeStatusBarItem.show();
        this.selectedSignalStatusBarItem.show();
      } else if (!e.webviewPanel.active && e.webviewPanel === this.activeWebview) {
        this.activeWebview  = undefined;
        this.activeDocument = undefined;
        this.netlistTreeDataProvider.hide();
        this.displayedSignalsTreeDataProvider.hide();
        this.deltaTimeStatusBarItem.hide();
        this.markerTimeStatusBarItem.hide();
        this.selectedSignalStatusBarItem.hide();
      }
    });

    // Subscribe to the expand/collapse events - For some reason we need to do
    // this because the collapsible state is not preserved when the tree view is refreshed
    this.netlistView.onDidExpandElement((element) => {
      if (!webviewPanel.active) {return;}
      if (element.element.collapsibleState === vscode.TreeItemCollapsibleState.None) {return;}
      element.element.collapsibleState = vscode.TreeItemCollapsibleState.Expanded;
    });

    this.netlistView.onDidCollapseElement((element) => {
      if (!webviewPanel.active) {return;}
      if (element.element.collapsibleState === vscode.TreeItemCollapsibleState.None) {return;}
      element.element.collapsibleState = vscode.TreeItemCollapsibleState.Collapsed;
    });

    // Subscribe to the checkbox state change event
    this.netlistView.onDidChangeCheckboxState((changedItem) => {

      //console.log('onDidChangeCheckboxState()');

      //console.log(changedItem);
      //console.log(this.netlistView);
      const metadata = changedItem.items[0][0];

      if (!webviewPanel.active) {return;}
      if (!document.webviewInitialized) {
        console.log('Webview not initialized');
        this.netlistTreeDataProvider.setCheckboxState(metadata, vscode.TreeItemCheckboxState.Unchecked);
        return;
      }

      const signalId   = metadata.signalId;
      const netlistId  = metadata.netlistId;

      // If the item is a parent node, uncheck it
      if (metadata.contextValue == "netlistScope") {
        this.netlistTreeDataProvider.setCheckboxState(metadata, vscode.TreeItemCheckboxState.Unchecked);
        return;
      }

      console.log(metadata);

      if (metadata.type === 'Real') {
        console.log('Real signals are not supported in the waveform viewer.');
        vscode.window.showWarningMessage('Real signals are not supported in the waveform viewer.');
        this.netlistTreeDataProvider.setCheckboxState(metadata, vscode.TreeItemCheckboxState.Unchecked);
        return;
      }

      if (metadata.checkboxState === vscode.TreeItemCheckboxState.Checked) {
        this.renderSignal(document, webviewPanel, metadata);
        const displayedItem = this.displayedSignalsTreeDataProvider.addSignalToTreeData(metadata);
        document.setNetlistIdTable(netlistId, displayedItem);
      } else if (metadata.checkboxState === vscode.TreeItemCheckboxState.Unchecked) {
        const displayedItem = document.netlistIdTable[netlistId]?.displayedItem;
        if (!displayedItem) {return;}
        this.removeSignalFromWebview(webviewPanel, netlistId);
        this.displayedSignalsTreeDataProvider.removeSignalFromTreeData(displayedItem);
        document.setNetlistIdTable(netlistId, undefined);
      }
    });

    this.displayedSignalsView.onDidChangeCheckboxState((changedItem) => {
      if (!webviewPanel.active) {return;}
      const metadata   = changedItem.items[0][0];
      const signalId   = metadata.signalId;
      const netlistId  = metadata.netlistId;
      const viewRef    = document.netlistIdTable[netlistId];

      if (!viewRef) {return;}

      if (metadata.checkboxState === vscode.TreeItemCheckboxState.Unchecked) {
        this.netlistTreeDataProvider.setCheckboxState(viewRef.netlistItem, vscode.TreeItemCheckboxState.Unchecked);
        this.displayedSignalsTreeDataProvider.removeSignalFromTreeData(metadata);
        this.removeSignalFromWebview(webviewPanel, netlistId);
        document.setNetlistIdTable(netlistId, undefined);
      }
    });

    // onDidChangeSelection() event returns readonly elements
    // so we need to copy the selected elements to a new array
    // Six one way, half a dozen the other. One is just more concise...
    this.netlistView.onDidChangeSelection((e) => {
      this.netlistViewSelectedSignals = [];
      e.selection.forEach((element) => {
        this.netlistViewSelectedSignals.push(element);
      });
    });

    this.displayedSignalsView.onDidChangeSelection((e) => {
      this.displayedSignalsViewSelectedSignals = [];
      e.selection.forEach((element) => {
        this.displayedSignalsViewSelectedSignals.push(element);
      });
    });

    //console.log("resolveCustomEditor()");
    // Add the webview to our internal set of active webviews
    this.webviews.add(document.uri, webviewPanel);
    this.activeWebview  = webviewPanel;
    this.activeDocument = document;
    this.lastActiveWebview = webviewPanel;
    this.lastActiveDocument = document;

    // Setup initial content for the webview
    webviewPanel.webview.options = {
      enableScripts: true,
    };
    webviewPanel.webview.html = this.getWebViewContent(webviewPanel.webview);

    this.netlistTreeDataProvider.loadDocument(document);
    this.displayedSignalsTreeDataProvider.setTreeData(this.activeDocument.displayedSignals);
  }

  private _requestId = 1;
  private readonly _callbacks = new Map<number, (response: any) => void>();

  private postMessageWithResponse<R = unknown>(panel: vscode.WebviewPanel, type: string, body: any): Promise<R> {
    const requestId = this._requestId++;
    const p = new Promise<R>(resolve => this._callbacks.set(requestId, resolve));
    panel.webview.postMessage({ type, requestId, body });
    return p;
  }

  //private onMessage(document: VaporviewDocument, message: any) {
  //  switch (message.type) {
  //    case 'response':
  //      {
  //        const callback = this._callbacks.get(message.requestId);
  //        callback?.(message.body);
  //        return;
  //      }
  //  }
  //}

  public removeSignalFromDocument(netlistId: NetlistId) {

    if (!this.activeWebview) {return;}
    if (!this.activeDocument) {return;}
    if (!this.activeWebview.active) {return;}

    const panel    = this.activeWebview;
    const document = this.activeDocument;

    this.removeSignalFromWebview(panel, netlistId);

    const metadataELements = document.netlistIdTable[netlistId];
    if (metadataELements) {
      const netlistItem = metadataELements.netlistItem;
      this.netlistTreeDataProvider.setCheckboxState(netlistItem, vscode.TreeItemCheckboxState.Unchecked);
      const displayedItem = metadataELements.displayedItem;
      if (displayedItem) {
        this.displayedSignalsTreeDataProvider.removeSignalFromTreeData(displayedItem);
        document.setNetlistIdTable(netlistId, undefined);
      }
    }
  }

  public async addSignalByNameToDocument(signalName: string) {
    if (!this.lastActiveDocument) {return;}

    // get msb and lsb from signal name
    const regex  = /\[(\d+:)?(\d+)\]$/;
    const field  = signalName.match(regex);
    const lookup = signalName.replace(regex, '');
    const msb   = field ? parseInt(field[1], 10) : undefined;
    const lsb   = field ? parseInt(field[2], 10) : msb;

    //console.log('lookup: ' + lookup + ' msb: ' + msb + ' lsb: ' + lsb);

    const metadata = await this.lastActiveDocument?.findTreeItem(lookup, msb, lsb);

    if (metadata === null) {
      console.log('Signal not found ' + signalName);
      return;
    }

    //console.log('found signal ' + signalName);

    const netlistId   = metadata.netlistId;
    const isDisplayed = this.webviewContext.displayedSignals.includes(netlistId as never);
    if (isDisplayed) {
      //console.log('Signal already displayed');
      if (this.lastActiveWebview) {
        this.lastActiveWebview.webview.postMessage({
          command: 'setSelectedSignal',
          netlistId: netlistId
        });
      }
    } else {
      //console.log('Adding signal to document');
      this.addSignalToDocument(metadata.netlistId, true);
    }
  }

  public addSignalToDocument(netlistId: NetlistId, addToLastActive: boolean) {

    let panel: vscode.WebviewPanel;
    let document: VaporviewDocument;

    if (!addToLastActive) {
      if (!this.activeWebview) {return;}
      if (!this.activeDocument) {return;}
      if (!this.activeWebview.active) {return;}

      panel    = this.activeWebview;
      document = this.activeDocument;
    } else {
      if (!this.lastActiveWebview) {return;}
      if (!this.lastActiveDocument) {return;}

      panel    = this.lastActiveWebview;
      document = this.lastActiveDocument;
    }

    const metadata = document.netlistIdTable[netlistId]?.netlistItem;
    if (!metadata) {return;}

    const signalId   = metadata.signalId;

    this.netlistTreeDataProvider.setCheckboxState(metadata, vscode.TreeItemCheckboxState.Checked);
    this.renderSignal(document, panel, metadata);
    const displayedItem = this.displayedSignalsTreeDataProvider.addSignalToTreeData(metadata);
    document.setNetlistIdTable(netlistId, displayedItem);
  }

  private async renderSignal(document: VaporviewDocument, panel: vscode.WebviewPanel, metadata: NetlistItem) {
    // Render the signal with the provided ID

    //console.log('renderSignal()');

    panel.webview.postMessage({ 
      command: 'add-variable',
      netlistId:  metadata.netlistId,
      signalId:   metadata.signalId,
      signalWidth: metadata.width,
      signalName: metadata.name,
      modulePath: metadata.modulePath,
      numberFormat: metadata.numberFormat
   });
  }

  private removeSignalFromWebview(panel: vscode.WebviewPanel, netlistId: NetlistId) {
    // Render the signal with the provided ID
    panel.webview.postMessage({ 
      command: 'remove-signal',
      netlistId: netlistId
   });
  }

  public filterAddSignalsInNetlist(netlistElements: NetlistItem[]) {

    const elementList = netlistElements.filter((element) => {
      return element.checkboxState === vscode.TreeItemCheckboxState.Unchecked && 
             element.contextValue === 'netlistVar' && 
             element.type !== 'Real';
    });

    if (elementList.length > 10) {
      // show warning message
      vscode.window.showWarningMessage('You are about to add a large number of signals to the waveform viewer. This may cause performance issues. Do you want to continue?', 'Yes', 'No').then((response) => {
        if (response === 'Yes') {
          this.renerSignalList(elementList);
        } 
      });
    } else {
      this.renerSignalList(elementList);
    }
  }

  public renerSignalList(netlistElements: NetlistItem[]) {
    if (!this.activeWebview) {return;}
    if (!this.activeDocument) {return;}
    if (!this.activeWebview.active) {return;}

    const panel       = this.activeWebview;
    const document    = this.activeDocument;

    netlistElements.forEach((element) => {
      const metadata   = element;
      const signalId   = metadata.signalId;
      const netlistId  = metadata.netlistId;
      this.netlistTreeDataProvider.setCheckboxState(metadata, vscode.TreeItemCheckboxState.Checked);
      this.renderSignal(document, panel, metadata);
      const displayedItem = this.displayedSignalsTreeDataProvider.addSignalToTreeData(metadata);
      document.setNetlistIdTable(netlistId, displayedItem);
    });
  }

  public removeSignalList(signalList: NetlistItem[]) {
    if (!this.activeWebview) {return;}
    if (!this.activeDocument) {return;}
    if (!this.activeWebview.active) {return;}

    signalList.forEach((element) => {
      const metadata  = element;
      const netlistId = metadata.netlistId;
      if (element.checkboxState === vscode.TreeItemCheckboxState.Checked) {
        this.removeSignalFromDocument(netlistId);
      }
    });
  }

  public removeSelectedSignalsFromDocument(view: string) {

    if (view === 'netlist') {
      this.removeSignalList(this.netlistViewSelectedSignals);
    } else if (view === 'displayedSignals') {
      this.removeSignalList(this.displayedSignalsViewSelectedSignals);
    }
  }

  public setValueFormat(id: NetlistId, format: number) {
    if (!this.activeWebview) {return;}
    if (!this.activeDocument) {return;}
    if (!this.activeWebview.active) {return;}

    const panel    = this.activeWebview;
    const document = this.activeDocument;

    const netlistRef = document.netlistIdTable[id];
    if (netlistRef) {
      netlistRef.netlistItem.numberFormat = format;
    }

    panel.webview.postMessage({command: 'setNumberFormat', netlistId: id, numberFormat: format});
  }

  // To do: implement nonce with this HTML:
  //<script nonce="${nonce}" src="${scriptUri}"></script>

  private getWebViewContent(webview: vscode.Webview): string {

    const extensionUri = this._context.extensionUri;

    const webAssets = {
      diamondUri:   webview.asWebviewUri(vscode.Uri.joinPath(extensionUri, 'media', 'diamond.svg')),
      svgIconsUri:  webview.asWebviewUri(vscode.Uri.joinPath(extensionUri, 'media', 'icons.svg')),
      jsFileUri:    webview.asWebviewUri(vscode.Uri.joinPath(extensionUri, 'media', 'vaporview.js')),
      cssFileUri:   webview.asWebviewUri(vscode.Uri.joinPath(extensionUri, 'media', 'style.css')),
      codiconsUri:  webview.asWebviewUri(vscode.Uri.joinPath(extensionUri, 'node_modules', '@vscode', 'codicons', 'dist', 'codicon.css')),
    };

    // Generate the HTML content
    const htmlContent = `
      <!DOCTYPE html>
      <html>
      <head>
        <title>VaporView - Waveform Viewer</title>
        <link rel="stylesheet" href="${webAssets.codiconsUri}"/>
        <link rel="stylesheet" href="${webAssets.cssFileUri}">
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link href="${webAssets.diamondUri}" rel="diamond.svg" type="image/svg+xml">
        <link href="${webAssets.svgIconsUri}" rel="icons.svg" type="image/svg+xml">
      </head>
      <body data-vscode-context='{"preventDefaultContextMenuItems":true}'>
        <div id="vaporview-top">
          <div id="control-bar">
            <svg xmlns="http://www.w3.org/2000/svg" style="display:none">
              <defs>
                <symbol id="binary-edge" viewBox="0 0 16 16">
                  <path d="M 2 14 L 2 14 L 8 14 L 8 3 C 8 1 8 1 10 1 L 14 1 L 14 2 L 9 2 L 9 13 C 9 15 9 15 7 15 L 2 15 L 2 14"/>
                </symbol>
                <symbol id="bus-edge" viewBox="0 0 16 16">
                  <path d="M 2 1 L 6 1 L 8 6 L 10 1 L 14 1 L 14 2 L 10.663 2 L 8.562 7.5 L 10.663 14 L 14 14 L 14 15 L 10 15 L 8 9 L 6 15 L 2 15 L 2 14 L 5.337 14 L 7.437 7.5 L 5.337 2 L 2 2 L 2 1"/>
                </symbol>
                <symbol id="arrow" viewBox="0 0 16 16">
                  <path d="M 1 7 L 1 8 L 6 8 L 4 10 L 4.707 10.707 L 7.914 7.5 L 4.707 4.293 L 4 5 L 6 7 L 6 7 L 1 7"/>
                </symbol>
                <symbol id="back-arrow" viewBox="0 0 16 16">
                  <use href="#arrow" transform="scale(-1, 1) translate(-16, 0)"/>
                </symbol>
                <symbol id="next-posedge" viewBox="0 0 16 16">
                  <use href="#arrow"/>
                  <use href="#binary-edge" transform="translate(3, 0)"/>
                </symbol>
                <symbol id="next-negedge" viewBox="0 0 16 16">
                  <use href="#arrow"/>
                  <use href="#binary-edge" transform="translate(3, 16) scale(1, -1)"/>
                </symbol>
                <symbol id="next-edge" viewBox="0 0 16 16">
                  <use href="#arrow"/>
                  <use href="#bus-edge" transform="translate(3, 0)"/>
                </symbol>
                <symbol id="previous-posedge" viewBox="0 0 16 16">
                  <use href="#back-arrow"/>
                  <use href="#binary-edge" transform="translate(-3, 0)"/>
                </symbol>
                <symbol id="previous-negedge" viewBox="0 0 16 16">
                  <use href="#back-arrow"/>
                  <use href="#binary-edge" transform="translate(-3, 16) scale(1, -1)"/>
                </symbol>
                <symbol id="previous-edge" viewBox="0 0 16 16">
                  <use href="#back-arrow"/>
                  <use href="#bus-edge" transform="translate(-3, 0)"/>
                </symbol>
                <symbol id="time-equals" viewBox="0 0 16 16">
                  <text x="8" y="8" class="icon-text">t=</text>
                </symbol>
                <symbol id="search-hex" viewBox="0 0 16 16">
                  <text x="8" y="8" class="icon-text">hex</text>
                </symbol>
                <symbol id="search-binary" viewBox="0 0 16 16">
                  <text x="8" y="8" class="icon-text">bin</text>
                </symbol>
                <symbol id="search-decimal" viewBox="0 0 16 16">
                  <text x="8" y="8" class="icon-text">dec</text>
                </symbol>
                <symbol id="search-enum" viewBox="0 0 16 16">
                  <text x="8" y="8" class="icon-text">Abc</text>
                </symbol>
                <symbol id="touchpad" viewBox="0 0 16 16">
                  <path d="M 1 2 L 1 10 C 1 11 2 11 2 11 L 3 11 L 3 10 L 2 10 L 2 2 L 14 2 L 14 10 L 12 10 L 12 11 L 14 11 C 14 11 15 11 15 10 L 15 2 C 15 2 15 1 14 1 L 2 1 C 1 1 1 2 1 2 M 4 14 L 5 14 L 5 11 C 5 10 5 9 6 9 C 7 9 7 10 7 11 L 7 14 L 8 14 L 8 9 C 8 8 8 7 9 7 C 10 7 10 8 10 9 L 10 14 L 11 14 L 11 9 C 11 7 10.5 6 9 6 C 7.5 6 7 7 7 8 L 7 8.5 C 6.917 8.261 6.671 8.006 6 8 C 4.5 8 4 9 4 11 L 4 14"/>
                </symbol>
              </defs>
            </svg>
            <div class="control-bar-group">
              <div class="control-bar-button" title="Zoom Out (Ctrl + scroll down)" id="zoom-out-button">
                <div class='codicon codicon-zoom-out' style="font-size:20px"></div>
              </div>
              <div class="control-bar-button" title="Zoom In (Ctrl + scroll up)" id="zoom-in-button">
                <div class='codicon codicon-zoom-in' style="font-size:20px"></div>
              </div>
            </div>
            <div class="control-bar-group">
              <div class="control-bar-button" title="Go To Previous Negative Edge Transition" id="previous-negedge-button">
                <svg class="custom-icon" viewBox="0 0 16 16"><use href="#previous-negedge"/></svg>
              </div>
              <div class="control-bar-button" title="Go To Previous Positive Edge Transition" id="previous-posedge-button">
                <svg class="custom-icon" viewBox="0 0 16 16"><use href="#previous-posedge"/></svg>
              </div>
              <div class="control-bar-button" title="Go To Previous Transition (Ctrl + &#8678;)" id="previous-edge-button">
                <svg class="custom-icon" viewBox="0 0 16 16"><use href="#previous-edge"/></svg>
              </div>
              <div class="control-bar-button" title="Go To Next Transition (Ctrl + &#8680;)" id="next-edge-button">
                <svg class="custom-icon" viewBox="0 0 16 16"><use href="#next-edge"/></svg>
              </div>
              <div class="control-bar-button" title="Go To Next Positive Edge Transition" id="next-posedge-button">
                <svg class="custom-icon" viewBox="0 0 16 16"><use href="#next-posedge"/></svg>
              </div>
              <div class="control-bar-button" title="Go To Next Negative Edge Transition" id="next-negedge-button">
                <svg class="custom-icon" viewBox="0 0 16 16"><use href="#next-negedge"/></svg>
              </div>
            </div>
            <div class="control-bar-group">
              <div id="search-container">
                <textarea id="search-bar" class="search-input" autocorrect="off" autocapitalize="off" spellcheck="false" wrap="off" aria-label="Find" placeholder="Search" title="Find"></textarea>
                <div class="search-button selected-button" title="Go to Time specified" id="time-equals-button">
                  <svg class="custom-icon" viewBox="0 0 16 16"><use href="#time-equals"/></svg>
                </div>
                <div class="search-button" title="Search by hex value" id="value-equals-button">
                  <svg class="custom-icon" viewBox="0 0 16 16"><use id="value-icon-reference" href="#search-hex"/></svg>
                </div>
              </div>
              <div class="control-bar-button" title="Previous" id="previous-button">
                <div class='codicon codicon-arrow-left' style="font-size:20px"></div>
              </div>
              <div class="control-bar-button" title="Next" id="next-button">
                <div class='codicon codicon-arrow-right' style="font-size:20px"></div>
              </div>
            </div>
            <div class="control-bar-group">
              <div class="format-button" title="Enable Touchpad Scrolling" id="touchpad-scroll-button">
                <svg class="custom-icon" viewBox="0 0 16 16"><use href="#touchpad"/></svg>
              </div>
            </div>
          </div>
          <div id="viewer-container">
            <div id="resize-1" class="resize-bar"></div>
            <div id="resize-2" class="resize-bar"></div>
          </div>
          <div id="waveform-labels-container" class="labels-container">
            <div id="waveform-labels-spacer" class="ruler-spacer"> </div>
            <div id="waveform-labels"> </div>
          </div>
          <div id="transition-display-container" class="labels-container">
            <div class="ruler-spacer"></div>
            <div id="transition-display"></div>
          </div>
          <div id="scrollArea">
            <div id="contentArea" tabindex="0"></div>
          </div>
          <div id="scrollbarContainer"><div id="scrollbar"></div></div>
        </div>
        <script src="${webAssets.jsFileUri}"></script>
      </body>
      </html>
    `;

    return htmlContent;
  }
}

// #region WebviewCollection
/**
 * Tracks all webviews.
 */
class WebviewCollection {

  private numWebviews = 0;
  public get getNumWebviews() {return this.numWebviews;}

  private readonly _webviews = new Set<{
    readonly resource: string;
    readonly webviewPanel: vscode.WebviewPanel;
  }>();

  /**
   * Get all known webviews for a given uri.
   */
  public *get(uri: vscode.Uri): Iterable<vscode.WebviewPanel> {
    const key = uri.toString();
    for (const entry of this._webviews) {
      if (entry.resource === key) {
        yield entry.webviewPanel;
      }
    }
  }

  /**
   * Add a new webview to the collection.
   */
  public add(uri: vscode.Uri, webviewPanel: vscode.WebviewPanel) {
    const entry = { resource: uri.toString(), webviewPanel };
    this._webviews.add(entry);
    this.numWebviews++;

    webviewPanel.onDidDispose(() => {
      this._webviews.delete(entry);
      this.numWebviews--;
    });
  }
}

// #region NetlistTreeDataProvider
export class NetlistTreeDataProvider implements vscode.TreeDataProvider<NetlistItem> {

  private treeData: NetlistItem[] = [];
  private _onDidChangeTreeData: vscode.EventEmitter<NetlistItem | undefined> = new vscode.EventEmitter<NetlistItem | undefined>();
  readonly onDidChangeTreeData: vscode.Event<NetlistItem | undefined> = this._onDidChangeTreeData.event;
  private document: VaporviewDocument | undefined;

  public setCheckboxState(netlistItem: NetlistItem, checkboxState: vscode.TreeItemCheckboxState) {
    netlistItem.checkboxState = checkboxState;
    this._onDidChangeTreeData.fire(undefined); // Trigger a refresh of the Netlist view
  }

  public loadDocument(document: VaporviewDocument) {
    this.setTreeData(document.treeData);
    this.document = document;
  }

  // Method to set the tree data
  public setTreeData(netlistItems: NetlistItem[]) {
    this.treeData = netlistItems;
    this._onDidChangeTreeData.fire(undefined); // Trigger a refresh of the Netlist view
  }

  public hide() {
    this.setTreeData([]);
    this.document = undefined;
  }

  public getTreeData(): NetlistItem[] {return this.treeData;}
  getTreeItem(element:  NetlistItem): vscode.TreeItem {return element;}
  getChildren(element?: NetlistItem): Thenable<NetlistItem[]> {
    return this.document?.getChildrenExternal(element) ?? Promise.resolve([]);
  }

  getParent(element: NetlistItem): vscode.ProviderResult<NetlistItem> {
    if (this.document) {
      return element.findChild(element.modulePath, this.document, undefined, undefined);
    }
    return null;
  }

  refresh(): void {
    this._onDidChangeTreeData.fire(undefined);
  }

}

class DisplayedSignalsViewProvider implements vscode.TreeDataProvider<NetlistItem> {
  private treeData: NetlistItem[] = [];
  private _onDidChangeTreeData: vscode.EventEmitter<NetlistItem | undefined> = new vscode.EventEmitter<NetlistItem | undefined>();
  readonly onDidChangeTreeData: vscode.Event<NetlistItem | undefined> = this._onDidChangeTreeData.event;

  // Method to set the tree data
  public setTreeData(netlistItems: NetlistItem[]) {
    this.treeData = netlistItems;
    this._onDidChangeTreeData.fire(undefined); // Trigger a refresh of the Netlist view
  }

  public hide() {
    this.setTreeData([]);
  }

  public getTreeData(): NetlistItem[] {return this.treeData;}

  getTreeItem(element:  NetlistItem): vscode.TreeItem {return element;}
  getChildren(element?: NetlistItem): Thenable<NetlistItem[]> {
    if (element) {return Promise.resolve(element.children);} // Return the children of the selected element
    else         {return Promise.resolve(this.treeData);} // Return the top-level netlist items
  }

  public addSignalToTreeData(netlistItem: NetlistItem): NetlistItem {
    const n = netlistItem;
    const displayedItem = new NetlistItem(n.label, n.type, n.width, n.signalId, n.netlistId, n.name, n.modulePath, n.msb, n.lsb, n.children, vscode.TreeItemCollapsibleState.None, n.checkboxState);
    displayedItem.iconPath = n.iconPath;
    this.treeData.push(displayedItem);
    this._onDidChangeTreeData.fire(undefined); // Trigger a refresh of the Netlist view
    return displayedItem;
  }

  public removeSignalFromTreeData(netlistItem: NetlistItem) {
    const index = this.treeData.indexOf(netlistItem);
    if (index > -1) {
      this.treeData.splice(index, 1);
    }
    this._onDidChangeTreeData.fire(undefined); // Trigger a refresh of the Netlist view
  }

  public getParent(element: NetlistItem): vscode.ProviderResult<NetlistItem> {
    return null;
  }

  refresh(): void {
    this._onDidChangeTreeData.fire(undefined);
  }
}

interface TreeCheckboxChangeEvent<T> {
  item: T;
  checked: boolean;
}

// #region NetlistItem
export class NetlistItem extends vscode.TreeItem {
  private _onDidChangeCheckboxState: vscode.EventEmitter<vscode.TreeItem | undefined | null> = new vscode.EventEmitter<vscode.TreeItem | undefined | null>();
  onDidChangeCheckboxState: vscode.Event<vscode.TreeItem | undefined | null> = this._onDidChangeCheckboxState.event;

  public numberFormat: number;

  constructor(
    public readonly label:      string,
    public readonly type:       string,
    public readonly width:      number,
    public readonly signalId:   SignalId, // Signal-specific information
    public readonly netlistId:  NetlistId, // Netlist-specific information
    public readonly name:       string,
    public readonly modulePath: string,
    public readonly msb:        number,
    public readonly lsb:        number,
    public children:         NetlistItem[] = [],
    public collapsibleState: vscode.TreeItemCollapsibleState,
    public checkboxState:    vscode.TreeItemCheckboxState | undefined = undefined // Display preference
  ) {
    super(label, collapsibleState);
    this.numberFormat = 16;
    if (collapsibleState === vscode.TreeItemCollapsibleState.None) {
      this.contextValue = 'netlistVar'; // Set a context value for leaf nodes
    } else {
      this.contextValue = 'netlistScope'; // Set a context value for parent nodes
    }
  }

  // Method to recursively find a child element in the tree
  async findChild(label: string, document: VaporviewDocument, msb: number | undefined, lsb: number | undefined): Promise<NetlistItem | null> {

    // If the label is empty, return the current item, but try to find the child with the specified msb and lsb
    if (label === '') {
      if (this.children.length === 0 || this.children === undefined) {return this;}
      if (msb === undefined || lsb === undefined) {return this;}
      if (this.msb === msb && this.lsb === lsb) {return this;}

      const returnItem = this.children.find(childItem => childItem.msb === msb && childItem.lsb === lsb);
      if (returnItem) {return returnItem;}
      return this;
    }

    const subModules    = label.split(".");
    const currentModule = subModules.shift();
    if (this.children.length === 0) {
      await document.getChildrenExternal(this);
    }

    const childItem     = this.children.find((child) => child.name === currentModule);

    if (childItem) {
      return await childItem.findChild(subModules.join("."), document, msb, lsb);
    } else {
      return null;
    }
  }

  handleCommand() {
    //console.log("handleCommand()");
    //console.log(this);
  }

  // Method to toggle the checkbox state
  toggleCheckboxState() {
    this.checkboxState = this.checkboxState === vscode.TreeItemCheckboxState.Checked
      ? vscode.TreeItemCheckboxState.Unchecked
      : vscode.TreeItemCheckboxState.Checked;
    this._onDidChangeCheckboxState.fire(this);
  }
}

// #region activate()
export async function activate(context: vscode.ExtensionContext) {

  //console.log('Loading WASM worker');

  // Load the Wasm module
  const binaryFile = vscode.Uri.joinPath(context.extensionUri, 'target', 'wasm32-unknown-unknown', wasmBuild, 'filehandler.wasm');
  const binaryData = await vscode.workspace.fs.readFile(binaryFile);
  wasmModule       = await WebAssembly.compile(binaryData);

  // Register Custom Editor Provider (The viewer window)
  // Associates .vcd files with vaporview extension
  // See package.json for more details
  const viewerProvider = new WaveformViewerProvider(context);

  vscode.window.registerCustomEditorProvider(
    'vaporview.waveformViewer',
    viewerProvider,
    {
      webviewOptions: {
        retainContextWhenHidden: true,
      },
      supportsMultipleEditorsPerDocument: false,
    });

  // Terminal link provider code
  // Detect UVM timestamps - ie: @ 1234
  const uvmTimestampRegex  = /@\s+(\d+)/g;
  // Detect timestamps with units - ie: 1.234 ns
  const timeStampWithUnits = /([\d,\.]+)\s*([kmµunpf]?s)/g;
  // Detect netlist elements in the terminal - ie: top.submodule.signal
  const netlistElement     = /[\w\$]+(\.[\w\$]+)+/g;

  interface CustomTerminalLink extends vscode.TerminalLink {data: string; type: string;}

  vscode.window.registerTerminalLinkProvider({
    provideTerminalLinks: (context: vscode.TerminalLinkContext, token: vscode.CancellationToken) => {

      const uvmTimestampMatches       = [...context.line.matchAll(uvmTimestampRegex)];
      const timeStampWithUnitsMatches = [...context.line.matchAll(timeStampWithUnits)];
      const netlistElementMatches     = [...context.line.matchAll(netlistElement)];

      const uvmTimestampLinks = uvmTimestampMatches.map(match => {
        const line       = context.line;
        const startIndex = line.indexOf(match[0]);

        return {
          startIndex,
          length: match[0].length,
          tooltip: 'Go to time: ' + match[1] + ' in waveform viewer',
          data: match[0],
          type: 'uvm-timestamp'
        } as CustomTerminalLink;
      });

      const timeStampWithUnitsLinks = timeStampWithUnitsMatches.map(match => {
        const line       = context.line;
        const startIndex = line.indexOf(match[0]);

        return {
          startIndex,
          length: match[0].length,
          tooltip: 'Go to ' + match[1] + ' ' + match[2] + ' in waveform viewer',
          data: match[0],
          type: 'timestamp-with-units'
        } as CustomTerminalLink;
      });

      const netlistElementLinks = netlistElementMatches.map(match => {
        const line       = context.line;
        const startIndex = line.indexOf(match[0]);

        return {
          startIndex,
          length: match[0].length,
          tooltip: 'Add "' + match[0] + '" to waveform viewer',
          data: match[0],
          type: 'netlist-element'
        } as CustomTerminalLink;
      });

      return [...uvmTimestampLinks, ...timeStampWithUnitsLinks, ...netlistElementLinks];
    },

    handleTerminalLink: (link: CustomTerminalLink) => {

      switch (link.type) {
        case 'uvm-timestamp': {
          const time = parseInt([...link.data.matchAll(uvmTimestampRegex)][0][1]);
          //console.log("UVM Timestamp link clicked: " + time);
          viewerProvider.setMarkerAtTime(time);
          break;
        }
        case 'timestamp-with-units': {
          const time  = parseFloat([...link.data.matchAll(timeStampWithUnits)][0][1]);
          const units = [...link.data.matchAll(timeStampWithUnits)][0][2];
          //console.log("Timestamp with units link clicked: " + time + '; units: ' + units);
          viewerProvider.setMarkerAtTimeWithUnits(time, units);
          break;
        }
        case 'netlist-element': {
          //console.log("Netlist element link clicked: " + link.data);
          viewerProvider.addSignalByNameToDocument(link.data);
          break;
        }
      }
    }
  });

  // I want to get semantic tokens for the current theme
  // The API is not available yet, so I'm just going to log the theme
  //vscode.window.onDidChangeActiveColorTheme((e) => {});

  // Commands
  context.subscriptions.push(vscode.commands.registerCommand('vaporview.viewVaporViewSidebar', () => {
    vscode.commands.executeCommand('workbench.view.extension.vaporView');
  }));

  // Add or remove signal commands
  context.subscriptions.push(vscode.commands.registerCommand('vaporview.removeSignal', (e) => {
    if (e.netlistId !== undefined) {
      viewerProvider.removeSignalFromDocument(e.netlistId);
    }
  }));

  context.subscriptions.push(vscode.commands.registerCommand('vaporview.addSelected', (e) => {
    viewerProvider.filterAddSignalsInNetlist(viewerProvider.netlistViewSelectedSignals);
  }));

  context.subscriptions.push(vscode.commands.registerCommand('vaporview.addAllInModule', (e) => {
    if (e.collapsibleState === vscode.TreeItemCollapsibleState.None) {return;}
    viewerProvider.filterAddSignalsInNetlist(e.children);
  }));

  context.subscriptions.push(vscode.commands.registerCommand('vaporview.removeSelectedNetlist', (e) => {
    viewerProvider.removeSelectedSignalsFromDocument('netlist');
  }));

  context.subscriptions.push(vscode.commands.registerCommand('vaporview.removeSelectedDisplayedSignals', (e) => {
    viewerProvider.removeSelectedSignalsFromDocument('displayedSignals');
  }));

  context.subscriptions.push(vscode.commands.registerCommand('vaporview.removeAllInModule', (e) => {
    if (e.collapsibleState === vscode.TreeItemCollapsibleState.None) {return;}
    viewerProvider.removeSignalList(e.children);
  }));

  context.subscriptions.push(vscode.commands.registerCommand('vaporview.showInNetlistView', (e) => {
    if (e.netlistId !== undefined) {
      viewerProvider.showInNetlistView(e.netlistId);
    }
  }));

  // Value Format commands
  context.subscriptions.push(vscode.commands.registerCommand('vaporview.displayAsBinary', (e) => {
    if (e.netlistId) {
      viewerProvider.setValueFormat(e.netlistId, 2);
    }
  }));

  context.subscriptions.push(vscode.commands.registerCommand('vaporview.displayAsHexadecimal', (e) => {
    if (e.netlistId) {
      viewerProvider.setValueFormat(e.netlistId, 16);
    }
  }));

  context.subscriptions.push(vscode.commands.registerCommand('vaporview.displayAsDecimal', (e) => {
    if (e.netlistId) {
      viewerProvider.setValueFormat(e.netlistId, 10);
    }
  }));

  // WaveDrom commands
  context.subscriptions.push(vscode.commands.registerCommand('vaporview.copyWaveDrom', (e) => {
    viewerProvider.copyWaveDrom();
  }));

  context.subscriptions.push(vscode.commands.registerCommand('vaporview.setWaveDromClockRising', (e) => {
    viewerProvider.setWaveDromClock('1', e.netlistId);
    //viewerProvider.webviewContext.waveDromClock = {edge: '1', netlistId: e.netlistId,};
  }));

  context.subscriptions.push(vscode.commands.registerCommand('vaporview.setWaveDromClockFalling', (e) => {
    //viewerProvider.webviewContext.waveDromClock = {edge: '0', netlistId: e.netlistId,};
    viewerProvider.setWaveDromClock('0', e.netlistId);
  }));

  context.subscriptions.push(vscode.commands.registerCommand('vaporview.unsetWaveDromClock', (e) => {
    //viewerProvider.webviewContext.waveDromClock = {edge: '1', netlistId: 0,};
    viewerProvider.setWaveDromClock('1', null);
  }));

  context.subscriptions.push(vscode.commands.registerCommand('vaporview.saveViewerSettings', (e) => {
    viewerProvider.saveSettingsToFile();
  }));

  context.subscriptions.push(vscode.commands.registerCommand('vaporview.loadViewerSettings', (e) => {
    viewerProvider.loadSettingsFromFile();
  }));

  context.subscriptions.push(vscode.commands.registerCommand('vaporview.reloadFile', (e) => {
    viewerProvider.reloadFile();
  }));
}

export default WaveformViewerProvider;

export function deactivate() {}
