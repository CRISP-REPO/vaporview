/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ([
/* 0 */,
/* 1 */
/***/ ((module) => {

module.exports = require("vscode");

/***/ })
/******/ 	]);
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
var exports = __webpack_exports__;

// Description: This file contains the extension logic for the VaporView extension
// This code was generated by ChatGPT 3.5 with a sequence of guided prompts
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deactivate = exports.activate = void 0;
const vscode = __webpack_require__(1);
class ActivityBarTreeDataProvider {
    constructor() {
        this._onDidChangeTreeData = new vscode.EventEmitter();
        this.onDidChangeTreeData = this._onDidChangeTreeData.event;
    }
    getTreeItem(element) {
        return element;
    }
    getChildren(element) {
        if (element) {
            // In this example, there are no child items, but you can define them as needed.
            return Promise.resolve([]);
        }
        else {
            // Create and return top-level items
            return Promise.resolve([
                new ActivityBarItem('Item 1', vscode.TreeItemCollapsibleState.None),
                new ActivityBarItem('Item 2', vscode.TreeItemCollapsibleState.None),
                // Add more items as needed
            ]);
        }
    }
    refresh() {
        this._onDidChangeTreeData.fire(undefined);
    }
}
class ActivityBarItem extends vscode.TreeItem {
    constructor(label, collapsibleState) {
        super(label, collapsibleState);
        this.label = label;
        this.collapsibleState = collapsibleState;
    }
}
class NetlistTreeDataProvider {
    constructor() {
        this.treeData = [];
        this._onDidChangeTreeData = new vscode.EventEmitter();
        this.onDidChangeTreeData = this._onDidChangeTreeData.event;
    }
    // Method to set the tree data
    setTreeData(netlistItems) {
        this.treeData = netlistItems;
        this._onDidChangeTreeData.fire(undefined); // Trigger a refresh of the Netlist view
    }
    getTreeItem(element) { return element; }
    getChildren(element) {
        if (element) {
            return Promise.resolve(element.children);
        } // Return the children of the selected element
        else {
            return Promise.resolve(this.treeData);
        } // Return the top-level netlist items
    }
    refresh() {
        this._onDidChangeTreeData.fire(undefined);
    }
}
class DisplayedSignalsViewProvider {
    constructor() {
        this.treeData = [];
        this._onDidChangeTreeData = new vscode.EventEmitter();
        this.onDidChangeTreeData = this._onDidChangeTreeData.event;
    }
    getTreeItem(element) { return element; }
    getChildren(element) {
        if (element) {
            return Promise.resolve(element.children);
        } // Return the children of the selected element
        else {
            return Promise.resolve(this.treeData);
        } // Return the top-level netlist items
    }
    addSignalToTreeData(netlistItem) {
        this.treeData.push(netlistItem);
        this._onDidChangeTreeData.fire(undefined); // Trigger a refresh of the Netlist view
    }
    removeSignalFromTreeData(netlistItem) {
        const index = this.treeData.indexOf(netlistItem);
        if (index > -1) {
            this.treeData.splice(index, 1);
        }
        this._onDidChangeTreeData.fire(undefined); // Trigger a refresh of the Netlist view
    }
    refresh() {
        this._onDidChangeTreeData.fire(undefined);
    }
}
class NetlistItem extends vscode.TreeItem {
    constructor(label, type, width, signalId, // Signal-specific information
    name, children = [], collapsibleState, checkboxState = vscode.TreeItemCheckboxState.Unchecked // Display preference
    ) {
        super(label, collapsibleState);
        this.label = label;
        this.type = type;
        this.width = width;
        this.signalId = signalId;
        this.name = name;
        this.children = children;
        this.collapsibleState = collapsibleState;
        this.checkboxState = checkboxState;
        this._onDidChangeCheckboxState = new vscode.EventEmitter();
        this.onDidChangeCheckboxState = this._onDidChangeCheckboxState.event;
        if (collapsibleState === vscode.TreeItemCollapsibleState.None) {
            this.contextValue = 'netlistItem'; // Set a context value for leaf nodes
        }
    }
    // Method to toggle the checkbox state
    toggleCheckboxState() {
        this.checkboxState = this.checkboxState === vscode.TreeItemCheckboxState.Checked
            ? vscode.TreeItemCheckboxState.Unchecked
            : vscode.TreeItemCheckboxState.Checked;
        this._onDidChangeCheckboxState.fire(this);
    }
}
const BASE_CHUNK_TIME_WINDOW = 512;
const TIME_INDEX = 0;
const VALUE_INDEX = 1;
class WaveformTop {
    constructor() {
        this.timeEnd = 0;
        this.filename = "";
        this.chunkSize = BASE_CHUNK_TIME_WINDOW;
        this.chunkCount = 0;
        this.timeUnit = "ns";
        this.timeScale = 1;
        this.netlistElements = new Map();
        console.log(this);
    }
    createSignalWaveform(name, signalId, width) {
        // Check if the signal waveform already exists, and if not, create a new one
        if (!this.netlistElements.has(signalId)) {
            let waveform = new SignalWaveform(name, width, this.chunkCount);
            this.netlistElements.set(signalId, waveform);
        }
    }
    setInitialState(signalId, initialState = "x") {
        // Check if the signal waveform exists in the map
        const waveform = this.netlistElements.get(signalId);
        if (waveform) {
            // Add the transition data to the signal waveform
            waveform.transitionData.push([0, initialState]);
            waveform.chunkStart[0] = 1;
        }
        else {
            // Console log an error message if the signal waveform doesn't exist
            console.log("${signalID} not in netlist");
        }
    }
    addTransitionData(signalId, transitionData, previousState) {
        // Check if the signal waveform exists in the map
        const waveform = this.netlistElements.get(signalId);
        if (waveform) {
            // Add the transition data to the signal waveform
            waveform.addTransitionData(transitionData, this.chunkSize);
        }
        else {
            // Console log an error message if the signal waveform doesn't exist
            console.log("${signalID} not in netlist");
        }
    }
}
class SignalWaveform {
    constructor(name, signalWidth, chunkCount) {
        this.name = name;
        this.signalWidth = signalWidth;
        this.chunkStart = new Array(chunkCount);
        this.transitionData = [];
    }
    addTransitionData(transitionValue, chunkSize) {
        const time = transitionValue[TIME_INDEX];
        const chunkIndex = Math.floor(time / chunkSize);
        const previousChunkIndex = Math.floor(this.transitionData[this.transitionData.length - 1][TIME_INDEX] / chunkSize);
        for (let i = previousChunkIndex + 1; i <= chunkIndex; i++) {
            this.chunkStart[i] = this.transitionData.length;
        }
        this.transitionData.push(transitionValue);
    }
}
// Function to parse a VCD file and update the Netlist view
async function parseVCDFile(vcdFilePath, netlistTreeDataProvider, waveformDataSet, waveformViewer) {
    try {
        // Read the VCD file using vscode.workspace.openTextDocument
        const vcdDocument = await vscode.workspace.openTextDocument(vscode.Uri.file(vcdFilePath));
        // Get the content of the document
        const vcdContent = vcdDocument.getText();
        waveformDataSet.filename = vcdFilePath;
        // Parse the VCD data for this specific file
        parseVCDData(vcdContent, netlistTreeDataProvider, waveformDataSet);
        console.log(waveformDataSet.netlistElements);
        // Optionally, you can refresh the Netlist view
        netlistTreeDataProvider.refresh();
        // Send a message to the webview to indicate that the VCD file is parsed
        waveformViewer.createTimeRuler();
        vscode.window.showInformationMessage('VCD file parsed successfully');
    }
    catch (error) {
        vscode.window.showErrorMessage('Error reading the VCD file: ' + error.message);
    }
}
// Function to parse the VCD data and populate the Netlist view
function parseVCDData(vcdData, netlistTreeDataProvider, waveformDataSet) {
    // Define a data structure to store the netlist items
    const netlistItems = [];
    const stack = [];
    let currentScope;
    let currentSignal = "";
    // Define variables to track the current state
    let currentTimestamp = 0;
    let initialState;
    const signalValues = new Map(); // Map to track signal values
    let currentMode = undefined;
    // Split VCD data into lines
    const lines = vcdData.split('\n');
    // Find the real minimum time step so that we can establish an apporpriate chunk size
    let previousTimeStamp = -9999999;
    let minTimeStemp = 9999999;
    for (const line of lines) {
        const cleanedLine = line.trim();
        if (cleanedLine.startsWith('#')) {
            // Extract timestamp
            const timestampMatch = cleanedLine.match(/#(\d+)/);
            if (timestampMatch) {
                const currentTimestamp = parseInt(timestampMatch[1]);
                minTimeStemp = Math.min(currentTimestamp - previousTimeStamp, minTimeStemp);
                previousTimeStamp = currentTimestamp;
            }
        }
    }
    console.log("minTimeStemp = " + minTimeStemp);
    for (const line of lines) {
        // Remove leading and trailing whitespace
        const cleanedLine = line.trim();
        if (cleanedLine.startsWith('$scope')) {
            currentMode = 'scope';
            // Extract the current scope
            const scopeMatch = cleanedLine.match(/\s+module\s+(\w+)/);
            if (scopeMatch) {
                const newScope = new NetlistItem(scopeMatch[1], 'module', 0, '', '', [], vscode.TreeItemCollapsibleState.Expanded);
                newScope.iconPath = new vscode.ThemeIcon('chip', new vscode.ThemeColor('charts.purple'));
                if (currentScope) {
                    currentScope.children.push(newScope); // Add the new scope as a child of the current scope
                }
                else {
                    netlistItems.push(newScope); // If there's no current scope, add it to the netlistItems
                }
                // Push the new scope onto the stack and set it as the current scope
                stack.push(newScope);
                currentScope = newScope;
            }
        }
        else if (cleanedLine.startsWith('$upscope')) {
            stack.pop(); // Pop the current scope from the stack
            currentScope = stack[stack.length - 1]; // Update the current scope to the parent scope
        }
        else if (cleanedLine.startsWith('$var')) {
            // Extract signal information (signal type and name)
            const varMatch = cleanedLine.match(/\$var\s+(wire|reg|integer|parameter|real)\s+(1|[\d+:]+)\s+(\w+)\s+(\w+(\[\d+)?(:\d+)?\]?)\s\$end/);
            if (varMatch && currentScope) {
                const varData = cleanedLine.split(/\s+/);
                const signalType = varMatch[1];
                const signalSize = parseInt(varMatch[2], 10);
                const signalID = varMatch[3];
                const signalNameWithField = varMatch[4];
                const signalName = signalNameWithField.split('[')[0];
                if (signalName !== currentSignal) {
                    // Create a NetlistItem for the signal and add it to the current scope
                    const signalItem = new NetlistItem(signalNameWithField, signalType, signalSize, signalID, signalName, [], vscode.TreeItemCollapsibleState.None, vscode.TreeItemCheckboxState.Unchecked);
                    // Assign an icon to the signal based on its type
                    if (signalType === 'wire') {
                        signalItem.iconPath = new vscode.ThemeIcon('symbol-interface', new vscode.ThemeColor('charts.pink'));
                    }
                    else if (signalType === 'reg') {
                        signalItem.iconPath = new vscode.ThemeIcon('database', new vscode.ThemeColor('charts.green'));
                    }
                    else if (signalType === 'integer') {
                        signalItem.iconPath = new vscode.ThemeIcon('symbol-variable', new vscode.ThemeColor('charts.blue'));
                    }
                    else if (signalType === 'parameter') {
                        signalItem.iconPath = new vscode.ThemeIcon('symbol-property', new vscode.ThemeColor('charts.orange'));
                    }
                    else if (signalType === 'real') {
                        signalItem.iconPath = new vscode.ThemeIcon('symbol-constant', new vscode.ThemeColor('charts.purple'));
                    }
                    currentScope.children.push(signalItem);
                }
                currentSignal = signalName;
                waveformDataSet.createSignalWaveform(signalNameWithField, signalID, signalSize);
            }
            // Parse out waveform data
        }
        else if (cleanedLine.startsWith('#')) {
            // Extract timestamp
            const timestampMatch = cleanedLine.match(/#(\d+)/);
            if (timestampMatch) {
                currentTimestamp = parseInt(timestampMatch[1]) / 1000;
            }
        }
        else if (cleanedLine.startsWith('b')) {
            // Extract signal value
            const valueMatch = cleanedLine.match(/b([01xzXZ]*)\s+(\w+)/);
            if (valueMatch) {
                const signalValue = valueMatch[1];
                const signalId = valueMatch[2];
                if (currentTimestamp !== 0) {
                    initialState = signalValues.get(signalId) || "x";
                    waveformDataSet.addTransitionData(signalId, [currentTimestamp, signalValue], initialState);
                }
                else {
                    waveformDataSet.setInitialState(signalId, signalValue);
                }
                // Update the state of the signal in the map
                signalValues.set(signalId, signalValue);
            }
        }
        else if (cleanedLine.startsWith('0') || cleanedLine.startsWith('1')) {
            // Extract signal value
            const valueMatch = cleanedLine.match(/([01xzXZ])(\w+)/);
            if (valueMatch) {
                const signalValue = valueMatch[1];
                const signalId = valueMatch[2];
                if (currentTimestamp !== 0) {
                    initialState = signalValues.get(signalId) || "x";
                    waveformDataSet.addTransitionData(signalId, [currentTimestamp, signalValue], initialState);
                }
                else {
                    waveformDataSet.setInitialState(signalId, signalValue);
                }
                // Update the state of the signal in the map
                signalValues.set(signalId, signalValue);
            }
        }
        else if (cleanedLine.startsWith('$timescale')) {
            currentMode = 'timescale';
        }
        else if (cleanedLine.startsWith('$end')) {
            currentMode = undefined;
        }
        if (currentMode === 'timescale') {
            const timescaleMatch = cleanedLine.match(/(\d+)\s+(\w+)/);
            if (timescaleMatch) {
                waveformDataSet.timeScale = parseInt(timescaleMatch[1]);
                waveformDataSet.timeUnit = timescaleMatch[2];
            }
        }
    }
    waveformDataSet.timeEnd = currentTimestamp + 1;
    signalValues.forEach((initialState, signalId) => {
        waveformDataSet.addTransitionData(signalId, [currentTimestamp, "x"], initialState);
    });
    // Update the Netlist view with the parsed netlist data
    netlistTreeDataProvider.setTreeData(netlistItems);
}
function activate(context) {
    // Activity Bar
    // Create an Activity Bar element
    const activityBarItem = vscode.window.createTreeView('vaporView', {
        treeDataProvider: new ActivityBarTreeDataProvider(),
    });
    context.subscriptions.push(activityBarItem);
    // Views
    // Create and register the Netlist view container
    const netlistTreeDataProvider = new NetlistTreeDataProvider();
    const netlistView = vscode.window.createTreeView('netlistContainer', {
        treeDataProvider: netlistTreeDataProvider,
    });
    context.subscriptions.push(netlistView);
    const displayedSignalsTreeDataProvider = new DisplayedSignalsViewProvider();
    const displayedSignalsView = vscode.window.createTreeView('displaylistContainer', {
        treeDataProvider: displayedSignalsTreeDataProvider,
    });
    context.subscriptions.push(displayedSignalsView);
    const waveformDataSet = new WaveformTop();
    // Status Bar
    // Create a status bar item for cursor time
    const cursorTimeStatusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right, 100);
    cursorTimeStatusBarItem.text = 'time: 0 ' + waveformDataSet.timeUnit;
    cursorTimeStatusBarItem.show();
    // Create a status bar item for selected signal
    const selectedSignalStatusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right, 100);
    selectedSignalStatusBarItem.text = 'Selected signal:';
    selectedSignalStatusBarItem.show();
    // Commands
    // Register a command to open the VaporView Sidebar
    context.subscriptions.push(vscode.commands.registerCommand('vaporview.viewVaporViewSidebar', () => {
        vscode.commands.executeCommand('workbench.view.extension.vaporView');
    }));
    context.subscriptions.push(vscode.commands.registerCommand('vaporview.viewWaveform', async () => {
        // Create and show a webview panel for the waveform viewer
        //TODO: create a more elegant caching solution for the webview panel
        const panel = vscode.window.createWebviewPanel('vaporView', 'VaporView - Waveform Viewer', vscode.ViewColumn.One, {
            retainContextWhenHidden: true,
            enableScripts: true,
            localResourceRoots: [
                vscode.Uri.joinPath(context.extensionUri, 'media'),
                vscode.Uri.joinPath(context.extensionUri, 'node_modules', '@vscode', 'codicons', 'dist'),
            ]
        });
        // Create an instance of the WaveformViewer class and pass your WaveformTop object
        const waveformViewer = new WaveformViewer(panel, context, waveformDataSet, cursorTimeStatusBarItem, selectedSignalStatusBarItem);
        // Subscribe to the checkbox state change event
        netlistView.onDidChangeCheckboxState((changedItem) => {
            const metadata = changedItem.items[0][0];
            const signalId = metadata.signalId;
            if (metadata.checkboxState === vscode.TreeItemCheckboxState.Checked) {
                waveformViewer.renderSignal(signalId);
            }
            else if (metadata.checkboxState === vscode.TreeItemCheckboxState.Unchecked) {
                waveformViewer.removeSignal(signalId);
            }
        });
        // Prompt the user to select a .vcd file
        const vcdFile = await vscode.window.showOpenDialog({
            openLabel: 'Open .vcd File',
            filters: {
                'VCD Files': ['vcd'],
                'All Files': ['*'],
            },
        });
        if (!vcdFile || vcdFile.length === 0) {
            vscode.window.showInformationMessage('No .vcd file selected.');
            return;
        }
        // vcdFile[0] is the user's selected .vcd file
        const selectedVcdFilePath = vcdFile[0].fsPath;
        // Call a function to parse the VCD file and update the Netlist view
        parseVCDFile(selectedVcdFilePath, netlistTreeDataProvider, waveformDataSet, waveformViewer);
        panel.onDidChangeViewState((e) => {
            console.log("onDidChangeViewState()");
            console.log(e);
        });
        panel.onDidDispose(() => {
            // When the panel is closed, clear out the netlist data
            netlistTreeDataProvider.setTreeData([]);
        });
    }));
}
exports.activate = activate;
class WaveformViewer {
    //private webAssets: { jsFileUri: string; cssFileUri: string; testImageUri: string;};
    constructor(panel, context, waveformDataSet, cursorTimeStatusBarItem, selectedSignalStatusBarItem) {
        this.panel = panel;
        this.context = context;
        this.waveformDataSet = waveformDataSet;
        const webview = this.panel.webview;
        const extensionUri = this.context.extensionUri;
        this.webAssets = {
            diamondUri: webview.asWebviewUri(vscode.Uri.joinPath(extensionUri, 'media', 'diamond.svg')),
            jsFileUri: webview.asWebviewUri(vscode.Uri.joinPath(extensionUri, 'media', 'vaporview.js')),
            cssFileUri: webview.asWebviewUri(vscode.Uri.joinPath(extensionUri, 'media', 'style.css')),
            testImageUri: webview.asWebviewUri(vscode.Uri.joinPath(extensionUri, 'media', 'wave_temp.png')),
            clusterize: webview.asWebviewUri(vscode.Uri.joinPath(extensionUri, 'media', 'clusterize_mod.js')),
            codiconsUri: webview.asWebviewUri(vscode.Uri.joinPath(extensionUri, 'node_modules', '@vscode', 'codicons', 'dist', 'codicon.css')),
        };
        // Send the 'init' message when the webview is created
        this.panel.webview.postMessage({ command: 'init' });
        // Set the HTML content (should be your initial loading content)
        this.panel.webview.html = this.getWebViewContent();
        // set up the message listener
        this.panel.webview.onDidReceiveMessage((message) => {
            switch (message.command) {
                case 'init': {
                    // Webview is initialized, send the 'init' message
                }
                case 'deleteSignal': {
                    // Receive a request to render a signal
                    const signalId = message.signalId;
                    //netlistTreeDataProvider.toggleCheckboxState();
                    //this.renderSignal(signalId);
                    break;
                }
                case 'setTime': {
                    cursorTimeStatusBarItem.text = 'time: ' + message.time + ' ' + this.waveformDataSet.timeUnit;
                    if (message.signal) {
                        selectedSignalStatusBarItem.text = 'Selected signal: ' + message.signal;
                        selectedSignalStatusBarItem.show();
                    }
                    else {
                        selectedSignalStatusBarItem.hide();
                    }
                }
            }
        });
    }
    createTimeRuler() {
        // Create and append the time ruler to the viewer
        // Customize and append the time ruler elements
        vscode.window.showInformationMessage('createtimeRuler()');
        this.panel.webview.postMessage({
            command: 'create-ruler',
            waveformDataSet: this.waveformDataSet
        });
    }
    showBasicLayout() {
        // Create and display the basic layout for the waveform viewer
    }
    renderSignal(signalId) {
        // Render the signal with the provided ID
        vscode.window.showInformationMessage('renderSignal()');
        this.panel.webview.postMessage({
            command: 'render-signal',
            waveformData: this.waveformDataSet.netlistElements.get(signalId),
            signalId: signalId
        });
    }
    removeSignal(signalId) {
        // Render the signal with the provided ID
        vscode.window.showInformationMessage('renderSignal()');
        this.panel.webview.postMessage({
            command: 'remove-signal',
            signalId: signalId
        });
    }
    getWebViewContent() {
        // Generate the HTML content
        const htmlContent = `
      <!DOCTYPE html>
      <html>
      <head>
        <title>VaporView - Waveform Viewer</title>
        <link rel="stylesheet" href="${this.webAssets.codiconsUri}"/>
        <link rel="stylesheet" href="${this.webAssets.cssFileUri}">
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link href="${this.webAssets.diamondUri}" rel="diamond.svg" type="image/svg+xml">
      </head>
      <body>
        <div id="vaporview-top">
          <div id="control-bar">
            <div class="control-bar-button" title="Zoom In (Ctrl + scroll up)" id="zoom-in-button"><div class='codicon codicon-zoom-in' style="font-size:20px"></div></div>
            <div class="control-bar-button" title="Zoom Out (Ctrl + scroll down)" id="zoom-out-button"><div class='codicon codicon-zoom-out' style="font-size:20px"></div></div>
          </div>
          <div id="waveform-labels-container">
            <div id="waveform-labels-spacer" class="ruler-spacer">
            </div>
            <div id="waveform-labels">
            </div>
          </div>
          <div id="resizeBar"></div>
          <div id="scrollArea" class="clusterize-scroll">
            <div id="contentArea" class="clusterize-content">
              <div class="clusterize-no-data">Loading data…</div>
            </div>
          </div>
        </div>
        <script src="${this.webAssets.clusterize}"></script>
        <script src="${this.webAssets.jsFileUri}"></script>
      </body>
      </html>
    `;
        return htmlContent;
    }
}
exports["default"] = WaveformViewer;
function deactivate() { }
exports.deactivate = deactivate;

})();

var __webpack_export_target__ = exports;
for(var i in __webpack_exports__) __webpack_export_target__[i] = __webpack_exports__[i];
if(__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, "__esModule", { value: true });
/******/ })()
;
//# sourceMappingURL=extension.js.map